#' Simulation calibration experiment for model
#'
#'
#' Takes provides model, y = f(x) and simulates calibration experiment. Provided model object represents idealize model E[y] ~ x  and must contain data.frame
#' with response and covariates for fitting. \code{sd1}  and \code{sd2} represents standard deviation of measurement errors during the calibration stage and prediction stage, respectively.
#' For each iteration, responses in the calibration stage are generated by y_i = f(x_i) + N(0,\code{sd1}) for each $i = 1,...,n. During the prediction stage, each provided \code{x0} generates an observed response
#' y_j' = f(x_0) + N(0,\code{sd2}) for j = 1,...,m. The calibration curve, f(x), is estimated via \code{\link{lm}} where \code{formula(object)} for observed data (x_1,y_1), ... , (x_n,y_n). For each x_0, the estiamted model, hat(f)(x), is used to
#' estimate $x_0$ based on its corresponding observed set (y_1', y_2, ...., y_m').
#'
#' @param object lm representing idealized calibration curve
#' @param x0 unknown values of $x$ over which $y'$ is to be generated
#' @param m length of independent $y'$ measurement to be genrated for each $x_0$
#' @param sd1 standard deviation of measurement error during calibration stage
#' @param sd2 standard deviation of measurement error during prediction stage
#' @param sims number of iterations
#'
#' @return A list containing the results of the simulation and simulation settings with the following components: \itemize{
#' \item{results}{A \code{data.frame} with the estimate and prediction interval for each x0}
#' \item{data}{A \code{data.frame} of the \emph{true} calibration curve contained within the provided model}
#'
#' }
#' @export
do_sim_multiple <- function(object, x0, m, sd1 =sd1, sd2 = sd2, sims = 1e3) {

  # Extract data, variable names, etc.
  .data  <-  eval(object$call$data, envir = parent.frame())
  yname <- all.vars(stats::formula(object)[[2]])

  # Predictor variable(s)
  multi <- FALSE
  xnames <- intersect(all.vars(stats::formula(object)[[3]]), colnames(.data))

  nd <- makeData(x0, xnames)

  n <- nrow(.data)
  out <- data.frame()

  for (i in 1:sims) {
    ys <- predict(object) + rnorm(n,mean = 0, sd = sd1)
    .data[yname] <- ys
    mod <- lm(stats::formula(object), data = .data)
    y0s <- predict(object, newdata = nd) + matrix(rnorm(m*length(x0),mean = 0, sd = sd2), nrow = length(x0))

    out1 <- foreach(y0 = iterators::iter(y0s, "row"), .combine = "rbind") %do%
      (invpred(object = mod, y0 = as.numeric(y0), interval =  "t")[-4]) %>% as.data.frame()
    out1$interval <- "t"
    out1$x0 <- x0

    if (m > 1) {
      out2 <- foreach(y0 = iterators::iter(y0s, "row"), .combine = "rbind") %do%
        (invpred(object = mod, y0 = as.numeric(y0), interval =  "bf")[-4])  %>% as.data.frame()
      out2$interval <- "bf"
      out2$x0 <- x0

      out3 <- foreach(y0 = iterators::iter(y0s, "row"), .combine = "rbind") %do%
        (invpred(object = mod, y0 = as.numeric(y0), interval =  "welch")[-4])  %>% as.data.frame()
      out3$interval <- "welch"
      out3$x0 <- x0

      out <- rbind(out,rbind(out1,out2, out3))
    } else {
      out <- rbind(out,rbind(out1))
    }


  }

  out$estimate <- unlist(out$estimate)
  out$lower <- unlist(out$lower)
  out$upper <- unlist(out$upper)

  return(out = list(results = out, data = .data, m  = m, sd1 = sd1, sd2 = sd2, formula = stats::formula(object), sims = sims))

}





